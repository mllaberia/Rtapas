devtools::install()
load_all()
devtools::document()
devtools::install()
one2one_f <- function(HS, reps = 1e+4, session = "sequential", cl = 1){
one2one <- function (HS, ...) {
HS.LUT <- which(HS == 1, arr.ind = TRUE)
HS.LUT <- cbind(HS.LUT,1:nrow(HS.LUT))
df <- as.data.frame(HS.LUT)
V <- rep(NA,reps)
for(i in 1:reps){
hs.lut <- subset(df[sample(nrow(df)),],
!duplicated(row) & !duplicated(col))
n <- sum(HS)
while (n >0) {
n <- n-1;
if (nrow(hs.lut) == n) break
}
V[i] <- n
}
V <- min(V)
return(V)
}
x <- ((one2one(HS, reps)-4):(one2one(HS, reps)+4))
y <- rep(NA, length(x))
for (i in 1:length(x)) {
THS <- trimHS_maxC(N, HS, n=x[i], check.unique = TRUE, session, cl)
y[i] <- length(THS)
}
plot(x, y, type = "b", xlim = c(1,8), xaxt = "n",
xlab = "Number of unique H-S associations",
ylab = "Number of runs accomplished") +
axis(1, seq(round(min(x)), round(max(x)), by = 1), labels = 1:8)
}
load_all()
devtools::document()
devtools::install()
load_all()
devtools::document()
devtools::install()
load_all()
devtools::document()
devtools::install()
use_r("link_freq")
load_all()
devtools::document()
devtools::install()
load_all()
devtools::document()
devtools::install()
load_all()
devtools::document()
devtools::install()
load_all()
devtools::document()
devtools::install()
load_all()
devtools::document()
devtools::install()
load_all()
devtools::document()
devtools::install()
load_all()
devtools::document()
devtools::install()
load_all()
devtools::document()
devtools::install()
load_all()
devtools::document()
devtools::install()
x <- c("n.max", "n.optimal")
n <- c(one2one(HS), nop(x,y))
r <- data.frame(x, n, row.names = NULL, col.names = NULL)
one2one <- function (HS, ...) {
HS.LUT <- which(HS == 1, arr.ind = TRUE)
HS.LUT <- cbind(HS.LUT,1:nrow(HS.LUT))
df <- as.data.frame(HS.LUT)
V <- rep(NA,reps)
for(i in 1:reps){
hs.lut <- subset(df[sample(nrow(df)),],
!duplicated(row) & !duplicated(col))
n <- sum(HS)
while (n >0) {
n <- n-1;
if (nrow(hs.lut) == n) break
}
V[i] <- n
}
V <- min(V)
return(V)
}
x <- ((one2one(HS, reps)-4):(one2one(HS, reps)+4))
y <- rep(NA, length(x))
for (i in 1:length(x)) {
THS <- trimHS_maxC(reps, HS, n=x[i], check.unique = TRUE, session, cl)
y[i] <- length(THS)
}
load_all()
devtools::document()
devtools::install()
load_all()
devtools::document()
devtools::install()
load_all()
devtools::document()
devtools::install()
use_r("tangle_gram")
use_r("one2one_f")
library(devtools)
library(roxygen2)
library(tidyverse)
use_r("one2one_f")
use_r("one2one_f")
load_all()
devtools::document()
devtools::install()
load_all()
devtools::document()
devtools::install()
load_all()
devtools::document()
devtools::install()
link.lwd
link.lwd?
?
?link.lwd
??link.lwd
use_r("linkf_CI")
use_r("link_freq")
load_all()
devtools::document()
devtools::install()
load_all()
devtools::document()
devtools::install()
use_r("geo_D")
gd_f <- future_sapply(hs, geoD, treeH, treeS)
use_r("paco_ss")
load_all()
devtools::document()
devtools::install()
load_all()
devtools::document()
devtools::install()
load_all()
devtools::document()
devtools::install()
load_all()
devtools::document()
devtools::install()
use_r("trimHS_maxC")
library(devtools)
library(roxygen2)
library(tidyverse)
use_r("trimHS_maxC")
load_all()
devtools::document()
devtools::install()
load_all()
devtools::document()
devtools::install()
load_all()
devtools::document()
devtools::install()
load_all()
devtools::document()
devtools::install()
use_r("trimHS_maxC")
linkf_CI <- function (hs, mTreeH, mTreeS, freqfun = "geo_D",
session = "sequential", cl = 1) {
freqfun.choice <- c("geo_D", "paco_ss")
if(freqfun %in% freqfun.choice == FALSE)
stop(writeLines("Invalid freqfun parameter.\r
Correct choices are 'geo_D' or 'paco_ss'"))
if(freqfun == "geo_D") {
LFGD01 <- link_freq(hs, GD, HS, percentile = 0.01, res.fq = TRUE)
GD01 <- matrix(NA, length(mTreeH), nrow(LFGD01))
if(session == "sequential"){
for(i in 1:length(mTreeH)) {
GD.CI <- geo_D(hs, treeH=mTreeH[[i]], treeS=mTreeS[[i]], session = "sequential", cl = 1)
LFGD01.CI <- link_freq(hs, GD.CI, HS, percentile=0.01, res.fq=TRUE)
GD01[i,] <- LFGD01.CI[,5]
}
return(GD01[i,])
} else {
for(i in 1:length(mTreeH)) {
GD.CI <- geo_D(hs, treeH=mTreeH[[i]], treeS=mTreeS[[i]], session = "multisession", cl = cl)
LFGD01.CI <- link_freq(hs, GD.CI, HS, percentile=0.01, res.fq=TRUE)
GD01[i,] <- LFGD01.CI[,5]
}
return(GD01[i,])
}
colnames(GD01) <- LFGD01[,3]
GD.LO <- apply(GD01, 2, quantile, 0.025)
GD.HI <- apply(GD01, 2, quantile, 0.975)
GD.AV <- apply(GD01, 2, mean)
return(GD.AV)
}
if(freqfun == "paco_ss") {
LFPACO01 <- link_freq(hs, PACO, HS, percentile = 0.01, res.fq = TRUE)
PACO01 <- matrix(NA, length(mTreeH), nrow(LFPACO01))
if(session == "sequential"){
for(i in 1:length(mTreeH)) {
PA.CI <- paco_ss(hs, treeH=mTreeH[[i]], treeS=mTreeS[[i]], symmetric=FALSE, ei.correct="none",
session = "sequential", cl = 1)
LFPA01.CI <- link_freq(hs, PA.CI, HS, percentile=0.01, res.fq=TRUE)
PACO01[i,] <- LFPA01.CI[,5]
}
return(PACO01[i,])
} else {
for(i in 1:length(mTreeH)) {
PA.CI <- paco_ss(hs, treeH=mTreeH[[i]], treeS=mTreeS[[i]], symmetric=FALSE, ei.correct="none",
session = "multisession", cl = cl)
LFPA01.CI <- link_freq(hs, PA.CI, HS, percentile=0.01, res.fq=TRUE)
PACO01[i,] <- LFPA01.CI[,5]
}
return(PACO01[i,])
}
colnames(PACO01) <- LFPACO01[,3]
PACO.LO <- apply(PACO01, 2, quantile, 0.025)
PACO.HI <- apply(PACO01, 2, quantile, 0.975)
PACO.AV <- apply(PACO01, 2, mean)
return(PACO.AV)
}
}
load_all()
devtools::document()
devtools::install()
load_all()
devtools::document()
devtools::install()
use_r("tangle_gram")
use_r("link_freq")
use_r("linkf_CI")
("trimHS_maxC")
library(devtools)
library(roxygen2)
library(tidyverse)
library(phytools)
use_r("trimHS_maxI")
library(RandomTaPas)
# load the data
HS <- as.matrix(read.table("C:/Users/Mar/Desktop/RTP_RPackage/RandomTaPas-master/OrchidBeeData/Orchids_x_Bees.txt", header = TRUE)) #bee-orchid
N= 1e+4
treeH <- read.nexus("C:/Users/Mar/Desktop/RTP_RPackage/RandomTaPas-master/OrchidBeeData/bees.tre")        #consensus tree, bees
treeS <- read.nexus("C:/Users/Mar/Desktop/RTP_RPackage/RandomTaPas-master/OrchidBeeData/orchids.tre")     #consensus tree, orchids
mTreeH <- read.nexus("C:/Users/Mar/Desktop/RTP_RPackage/RandomTaPas-master/OrchidBeeData/mBees.tre")      #1000 post. prob. Bayesian trees, bees
mTreeS <- read.nexus("C:/Users/Mar/Desktop/RTP_RPackage/RandomTaPas-master/OrchidBeeData/mOrchids.tre")   #idem, orchids
# Run Random TaPas with consensus trees #######################################
n <- one2one_f(HS, reps = 1e+4, plot = TRUE)
n <- n[2,2]
THSI <- trimHS_maxI(N, HS, n, check.unique = TRUE)
trimHS_maxI <- function (N, HS, n, check.unique=TRUE) {
trim.intI <- function (HS, n) {
HS.LUT <- which(HS == 1, arr.ind = TRUE)
HS.LUT <- cbind(HS.LUT,1:nrow(HS.LUT))
LH <- LS <- 1
while(LH <= 1 | LS <= 1) {  # skip configurations with only
HS.trim <- HS.LUT[sample(nrow(HS.LUT), n), ] # one H or one S
LH <- length(unique(HS.trim[, 1]))
LS <- length(unique(HS.trim[, 2]))
}
hs <- HS
hs[ , ] <- 0
for (j in 1:nrow(HS.trim)) {
hs[HS.trim[j,1], HS.trim[j,2]] <- 1
}
hs <- hs[-which(rowSums(hs) == 0), -which(colSums(hs) == 0)]
return(hs)
}
trimI.HS <- replicate(N, trim.intI(HS=HS, n=n))
if (check.unique == TRUE) trimI.HS <- unique(trimI.HS)
return(trimI.HS)
}
THSI[sapply(THSI, is.null)] <- NULL
THSI <- trimHS_maxI(N, HS, n, check.unique = TRUE)
THSI[sapply(THSI, is.null)] <- NULL
PACO <- paco_ss(THSI, treeH, treeS, symmetric = FALSE,
ei.correct = "sqrt.D", session = "sequential", 1)
LFPACO01 <- link_freq(THSI, PACO, HS, percentile = 0.01, below.p = FALSE, res.fq = TRUE)
# Heatmaps on tanglegram ##############################
# Set color scale - this one is supposed to be color-blind friendly
col.scale <- c("darkred","gray90", "darkblue")
dev.off()
tangle_gram(treeH, treeS, HS, colscale= "diverging", colgrad=col.scale,
nbreaks=50, LFPACO01, res.fq=TRUE, link.lwd=1, link.lty=1, fsize=0.5,
pts=FALSE, link.type="curved", node.tag=TRUE,
cexpt=1.2)
tangle_gram(treeH, treeS, HS, colscale= "sequential", colgrad=col.scale,
nbreaks=50, LFPACO01, res.fq=TRUE, link.lwd=1, link.lty=1, fsize=0.5,
pts=FALSE, link.type="curved", node.tag=TRUE,
cexpt=1.2)
tangle_gram(treeH, treeS, HS, colscale= "sequential", colgrad=col.scale,
nbreaks=50, LFPACO01, res.fq=TRUE, link.lwd=1, link.lty=1, fsize=0.3,
pts=FALSE, link.type="curved", node.tag=TRUE,
cexpt=1.2)
# Heatmaps on tanglegram ##############################
# Set color scale - this one is supposed to be color-blind friendly
col.scale <- c("darkred","gray90", "darkblue", "red")
dev.off()
tangle_gram(treeH, treeS, HS, colscale= "sequential", colgrad=col.scale,
nbreaks=50, LFPACO01, res.fq=TRUE, link.lwd=1, link.lty=1, fsize=0.3,
pts=FALSE, link.type="curved", node.tag=TRUE,
cexpt=1.2)
PACO <- paco_ss(THSI, treeH, treeS, symmetric = FALSE,
ei.correct = "sqrt.D", session = "sequential", 1)
library(devtools)
library(roxygen2)
library(tidyverse)
load_all()
devtools::document()
devtools::install()
load_all()
devtools::document()
devtools::install()
library(RandomTaPas)
# load the data
HS <- as.matrix(read.table("C:/Users/Mar/Desktop/RTP_RPackage/RandomTaPas-master/OrchidBeeData/Orchids_x_Bees.txt", header = TRUE)) #bee-orchid
N= 1e+4
treeH <- read.nexus("C:/Users/Mar/Desktop/RTP_RPackage/RandomTaPas-master/OrchidBeeData/bees.tre")        #consensus tree, bees
treeS <- read.nexus("C:/Users/Mar/Desktop/RTP_RPackage/RandomTaPas-master/OrchidBeeData/orchids.tre")     #consensus tree, orchids
mTreeH <- read.nexus("C:/Users/Mar/Desktop/RTP_RPackage/RandomTaPas-master/OrchidBeeData/mBees.tre")      #1000 post. prob. Bayesian trees, bees
mTreeS <- read.nexus("C:/Users/Mar/Desktop/RTP_RPackage/RandomTaPas-master/OrchidBeeData/mOrchids.tre")   #idem, orchids
n <- 26
THSI <- trimHS_maxI(N, HS, n, check.unique = TRUE)
THSI[sapply(THSI, is.null)] <- NULL
PACO <- paco_ss(THSI, treeH, treeS, symmetric = FALSE,
ei.correct = "sqrt.D", session = "sequential", 1)
# Extract frequency distributions
LFPACO01 <- link_freq(THSI, PACO, HS, percentile = 0.01, below.p = FALSE, res.fq = TRUE)
# Heatmaps on tanglegram ##############################
# Set color scale - this one is supposed to be color-blind friendly
col.scale <- c("darkred","gray90", "darkblue", "red")
dev.off()
tangle_gram(treeH, treeS, HS, colscale= "sequential", colgrad=col.scale,
nbreaks=50, LFPACO01, res.fq=TRUE, link.lwd = 1, link.lty = 1, fsize = 0.3,
pts=FALSE, link.type="curved", node.tag=TRUE,
cexpt=1.2)
library(RandomTaPas)
# load the data
HS <- as.matrix(read.table("C:/Users/Mar/Desktop/RTP_RPackage/RandomTaPas-master/OrchidBeeData/Orchids_x_Bees.txt", header = TRUE)) #bee-orchid
N= 1e+4
treeH <- read.nexus("C:/Users/Mar/Desktop/RTP_RPackage/RandomTaPas-master/OrchidBeeData/bees.tre")        #consensus tree, bees
treeS <- read.nexus("C:/Users/Mar/Desktop/RTP_RPackage/RandomTaPas-master/OrchidBeeData/orchids.tre")     #consensus tree, orchids
mTreeH <- read.nexus("C:/Users/Mar/Desktop/RTP_RPackage/RandomTaPas-master/OrchidBeeData/mBees.tre")      #1000 post. prob. Bayesian trees, bees
mTreeS <- read.nexus("C:/Users/Mar/Desktop/RTP_RPackage/RandomTaPas-master/OrchidBeeData/mOrchids.tre")   #idem, orchids
# Run Random TaPas with consensus trees #######################################
n <- one2one_f(HS, reps = 1e+4, plot = TRUE)
n <- n[2, 2]
THS <- trimHS_maxC(N, HS, n, check.unique = TRUE, session = "sequential", 1)
THS[sapply(THS, is.null)] <- NULL
THSI <- trimHS_maxI(N, HS, n, check.unique = TRUE)
THSI[sapply(THSI, is.null)] <- NULL
GD <- geo_D(THS, treeH, treeS, session = "sequential", 1)
PACO <- paco_ss(THS, treeH, treeS, symmetric = FALSE,
ei.correct = "sqrt.D", session = "sequential", 1)
# Extract frequency distributions
LFGD01 <- link_freq(THS, GD, HS, percentile = 0.01, res.fq = TRUE)
LFPACO01 <- link_freq(THS, PACO, HS, percentile = 0.01, res.fq = TRUE)
# Run Random TaPas, 2x1000 posterior prob. trees #############################
GD01 <- matrix(NA, length(mTreeH), nrow(LFGD01))
PACO01 <- matrix(NA, length(mTreeH), nrow(LFPACO01))
# Run Random TaPas, 2x1000 posterior prob. trees #############################
GD01 <- matrix(NA, length(mTreeH), nrow(LFGD01))
PACO01 <- matrix(NA, length(mTreeH), nrow(LFPACO01))
GD_CI <- linkf_CI(THS, mTreeH[1:10], mTreeS[1:10], freqfun = "geo_D",
session = "multisession", cl = 16)
# Heatmaps on tanglegram ##############################
# Set color scale - this one is supposed to be color-blind friendly
col.scale <- c("darkred","gray90", "darkblue")
# GD results:
dev.off()
tangle_gram(treeH, treeS, HS, colscale= "diverging", colgrad=col.scale,
nbreaks=50, LFGD01, res.fq=TRUE, link.lwd=1, link.lty=1, fsize=0.5,
pts=FALSE, link.type="curved", node.tag=TRUE,
cexpt=1.2)
library(phytools)
library(RandomTaPas)
tangle_gram(treeH, treeS, HS, colscale= "diverging", colgrad=col.scale,
nbreaks=50, LFGD01, res.fq=TRUE, link.lwd=1, link.lty=1, fsize=0.5,
pts=FALSE, link.type="curved", node.tag=TRUE,
cexpt=1.2)
tangle_gram(treeH, treeS, HS, colscale= "sequential", colgrad= col.scale,
nbreaks=50, LFPACO01, res.fq=TRUE, node.tag=TRUE, cexpt=1.2,
link.lwd=1, link.lty=1, fsize=0.5, pts=FALSE, link.type="curved",
ftype="i")
library(Random)
library(RandomTaPas)
tangle_gram(treeH, treeS, HS, colscale= "diverging", colgrad= col.scale,
nbreaks=50, LFPACO01, res.fq=TRUE,
link.lwd=1, link.lty=1, fsize=0.5, pts=FALSE, link.type="curved",
node.tag=TRUE, cexpt=1.2, ftype="i")
library(RandomTaPas)
# PACo results:
dev.off()
tangle_gram(treeH, treeS, HS, colscale= "sequential", colgrad= col.scale,
nbreaks=50, LFPACO01, res.fq=TRUE, node.tag=TRUE, cexpt=1.2,
link.lwd=1, link.lty=1, fsize=0.5, pts=FALSE, link.type="curved",
ftype="i")
# PACo results:
dev.off()
tangle_gram(treeH, treeS, HS, colscale= "diverging", colgrad= col.scale,
nbreaks=50, LFPACO01, res.fq=TRUE,
link.lwd=1, link.lty=1, fsize=0.5, pts=FALSE, link.type="curved",
node.tag=TRUE, cexpt=1.2, ftype="i")
# PACo results:
dev.off()
tangle_gram(treeH, treeS, HS, colscale= "sequential", colgrad= col.scale,
nbreaks=50, LFPACO01, res.fq=TRUE, node.tag = TRUE, cexpt = 1)
library(RandomTaPas)
tangle_gram(treeH, treeS, HS, colscale= "sequential", colgrad= col.scale,
nbreaks=50, LFPACO01, res.fq=TRUE, node.tag=TRUE, cexpt=1.2,
link.lwd=1, link.lty=1, fsize=0.5, pts=FALSE, link.type="curved",
ftype="i")
tangle_gram(treeH, treeS, HS, colscale= "diverging", colgrad= col.scale,
nbreaks=50, LFPACO01, res.fq=TRUE,
link.lwd=1, link.lty=1, fsize=0.5, pts=FALSE, link.type="curved",
node.tag=TRUE, cexpt=1.2, ftype="i")
library(RandomTaPas)
tangle_gram(treeH, treeS, HS, colscale= "diverging", colgrad= col.scale,
nbreaks=50, LFPACO01, res.fq=TRUE,
link.lwd=1, link.lty=1, fsize=0.5, pts=FALSE, link.type="curved",
node.tag=TRUE, cexpt=1.2, ftype="i")
library(RandomTaPas)
tangle_gram(treeH, treeS, HS, colscale= "diverging", colgrad= col.scale,
nbreaks=50, LFPACO01, res.fq=TRUE,
link.lwd=1, link.lty=1, fsize=0.5, pts=FALSE, link.type="curved",
node.tag=TRUE, cexpt=1.2, ftype="i")
tangle_gram(treeH, treeS, HS, colscale= "diverging", colgrad= col.scale,
nbreaks=50, LFPACO01, res.fq=TRUE,
link.lwd=1, link.lty=1, fsize=1, pts=FALSE, link.type="curved",
node.tag=TRUE, cexpt=1.2, ftype="i")
tangle_gram(treeH, treeS, HS, colscale= "diverging", colgrad= col.scale,
nbreaks=50, LFPACO01, res.fq=TRUE,
link.lwd=1, link.lty=1, fsize=1, pts=FALSE, link.type="curved",
node.tag=TRUE, cexpt=1.2, ftype="i")
library(RandomTaPas)
tangle_gram(treeH, treeS, HS, colscale= "sequential", colgrad= col.scale,
nbreaks=50, LFPACO01, res.fq=TRUE, node.tag=TRUE, cexpt=1.2,
link.lwd=1, link.lty=1, fsize=0.5, pts=FALSE, link.type="curved",
ftype="i")
tangle_gram(treeH, treeS, HS, colscale= "diverging", colgrad= col.scale,
nbreaks=50, LFPACO01, res.fq=TRUE,
link.lwd=1, link.lty=1, fsize=1, pts=FALSE, link.type="curved",
node.tag=TRUE, cexpt=1.2, ftype="i")
tangle_gram(treeH, treeS, HS, colscale= "diverging", colgrad= col.scale,
nbreaks=50, LFPACO01, res.fq=TRUE,
link.lwd=1, link.lty=1, fsize=0.5, pts=FALSE, link.type="curved",
node.tag=TRUE, cexpt=1.2, ftype="i")
dev.off()
tangle_gram(treeH, treeS, HS, colscale= "diverging", colgrad= col.scale,
nbreaks=50, LFPACO01, res.fq=TRUE,
link.lwd=1, link.lty=1, fsize=0.5, pts=FALSE, link.type="curved",
node.tag=TRUE, cexpt=1.2, ftype="i")
dev.off()
tangle_gram(treeH, treeS, HS, colscale= "diverging", colgrad= col.scale,
nbreaks=50, LFPACO01, res.fq=TRUE,
link.lwd=1, link.lty=1, fsize=0.5, pts=FALSE, link.type="curved",
node.tag=TRUE, cexpt=1.2, ftype="i")
dev.off()
library(RandomTaPas)
library(RandomTaPas)
# load the data
HS <- as.matrix(read.table("C:/Users/Mar/Desktop/RTP_RPackage/RandomTaPas-master/OrchidBeeData/Orchids_x_Bees.txt", header = TRUE)) #bee-orchid
N= 1e+4
treeH <- read.nexus("C:/Users/Mar/Desktop/RTP_RPackage/RandomTaPas-master/OrchidBeeData/bees.tre")        #consensus tree, bees
treeS <- read.nexus("C:/Users/Mar/Desktop/RTP_RPackage/RandomTaPas-master/OrchidBeeData/orchids.tre")     #consensus tree, orchids
mTreeH <- read.nexus("C:/Users/Mar/Desktop/RTP_RPackage/RandomTaPas-master/OrchidBeeData/mBees.tre")      #1000 post. prob. Bayesian trees, bees
mTreeS <- read.nexus("C:/Users/Mar/Desktop/RTP_RPackage/RandomTaPas-master/OrchidBeeData/mOrchids.tre")   #idem, orchids
# Run Random TaPas with consensus trees #######################################
n <- one2one_f(HS, reps = 1e+4, plot = TRUE)
n <- n[2, 2]
THS <- trimHS_maxC(N, HS, n, check.unique = TRUE, session = "sequential", 1)
THS[sapply(THS, is.null)] <- NULL
# Run Random TaPas, 2x1000 posterior prob. trees #############################
GD01 <- matrix(NA, length(mTreeH), nrow(LFGD01))
PACO01 <- matrix(NA, length(mTreeH), nrow(LFPACO01))
# Extract frequency distributions
LFGD01 <- link_freq(THS, GD, HS, percentile = 0.01, res.fq = TRUE)
LFPACO01 <- link_freq(THS, PACO, HS, percentile = 0.01, res.fq = TRUE)
GD <- geo_D(THS, treeH, treeS, session = "sequential", 1)
PACO <- paco_ss(THS, treeH, treeS, symmetric = FALSE,
ei.correct = "sqrt.D", session = "sequential", 1)
# Run Random TaPas, 2x1000 posterior prob. trees #############################
GD_CI <- linkf_CI(THS, mTreeH[1:10], mTreeS[1:10], freqfun = "geo_D", geoD = GD,
session = "multisession", cl = 16)
PACO_CI <- linkf_CI(THS, mTreeH[1:10], mTreeS[1:10], freqfun = "paco_ss", paco = PACO,
session = "multisession", cl = 16)
linkf_CI(THS, mTreeH[1:10], mTreeS[1:10], freqfun = "geo_D", geoD = GD,
session = "multisession", cl = 16)
GD_CI
library(paco)
library(phytools)
library(distory)
library(GiniWegNeg)
library(parallel)
GD01 <- matrix(NA, length(mTreeH[1:10]), nrow(LFGD01))
# Extract frequency distributions
LFGD01 <- link_freq(THS, GD, HS, percentile = 0.01, res.fq = TRUE)
GD01 <- matrix(NA, length(mTreeH[1:10]), nrow(LFGD01))
cores <- detectCores()
pb <- txtProgressBar(min = 0, max = length(mTreeH[1:10]), style = 3)
cl <- makeCluster(cores-2)    # use nº CPUs - 2 for parallel computing
for(i in 1:length(mTreeH[1:10]))		# CIs for GD
{
GD.CI<-parallel::parSapply(cl, THS, geo.D, treeH=mTreeH[[i]],
treeS= mTreeS[[i]])
LFGD01.CI <- link.freq(THS, GD.CI, HS, percentile=0.01)
GD01[i,] <- LFGD01.CI[,5]
setTxtProgressBar(pb, i)
}
