return(GD01)
}
cl=5
if(strat == "sequential") {
GD01 <- t(sapply(1:length(mTreeH), function(x) gd_apply(ths, mTreeH[[x]], mTreeS[[x]], HS)))
colnames(GD01) <- LFGD01[,3]
return(GD01)
} else {
cores <- makeClusterPSOCK(workers = cl)
GD01 <- t(parSapply(cores, 1:length(mTreeH), function(x) gd_apply(ths, treeH=mTreeH[[x]], treeS=mTreeS[[x]], HS)))
colnames(GD01) <- LFGD01[,3]
return(GD01)
}
gd_apply <- function(ths, mTreeH, mTreeS, HS) {
GD.CI <- RandomTaPas::geo_D(ths, treeH=mTreeH, treeS=mTreeS)
LFGD01.CI <- RandomTaPas::link_freq(ths, GD.CI, HS, percentile = percentile,
res.fq = res.fq, below.p = below.p)
return(LFGD01.CI[, ncol(LFGD01.CI)])
}
if(strat == "sequential") {
GD01 <- t(sapply(1:length(mTreeH), function(x) gd_apply(ths, mTreeH[[x]], mTreeS[[x]], HS)))
colnames(GD01) <- LFGD01[,3]
return(GD01)
} else {
cores <- makeClusterPSOCK(workers = cl)
clusterExport(cl=cores, c("gd_apply"))
GD01 <- t(parSapply(cores, 1:length(mTreeH), function(x) gd_apply(ths, treeH=mTreeH[[x]], treeS=mTreeS[[x]], HS)))
colnames(GD01) <- LFGD01[,3]
return(GD01)
}
GD01 <- t(parSapply(cores, 1:length(mTreeH), function(x) gd_apply(ths = THS, mTreeH[[x]], mTreeS[[x]], HS)))
if(strat == "sequential") {
GD01 <- t(sapply(1:length(mTreeH), function(x) gd_apply(ths, mTreeH[[x]], mTreeS[[x]], HS)))
colnames(GD01) <- LFGD01[,3]
return(GD01)
} else {
cores <- makeClusterPSOCK(workers = cl)
clusterExport(cl=cores, c("gd_apply"))
GD01 <- t(parSapply(cores, 1:length(mTreeH), function(x) gd_apply(ths = THS, mTreeH[[x]], mTreeS[[x]], HS)))
colnames(GD01) <- LFGD01[,3]
return(GD01)
}
cores <- makeClusterPSOCK(workers = cl)
GD01 <- parSapply(cores, 1:length(mTreeH), gd_apply, mTreeH[[x]], mTreeS[[x]], HS)
if(strat == "sequential") {
GD01 <- t(sapply(1:length(mTreeH), function(x) gd_apply(ths, mTreeH[[x]], mTreeS[[x]], HS)))
colnames(GD01) <- LFGD01[,3]
return(GD01)
} else {
cores <- makeClusterPSOCK(workers = cl)
for(i in 1:length(mTreeH)){
GD01 <- parSapply(cores, 1:length(mTreeH), gd_apply, mTreeH[[x]], mTreeS[[x]], HS)
}
colnames(GD01) <- LFGD01[,3]
return(GD01)
}
GD01 <- parSapply(cores, 1:length(mTreeH), gd_apply, mTreeH[[i]], mTreeS[[i]], HS)
if(strat == "sequential") {
GD01 <- t(sapply(1:length(mTreeH), function(x) gd_apply(ths, mTreeH[[x]], mTreeS[[x]], HS)))
colnames(GD01) <- LFGD01[,3]
return(GD01)
} else {
cores <- makeClusterPSOCK(workers = cl)
for(i in 1:length(mTreeH)){
GD01 <- parSapply(cores, 1:length(mTreeH), gd_apply, mTreeH[[i]], mTreeS[[i]], HS)
}
colnames(GD01) <- LFGD01[,3]
return(GD01)
}
if(strat == "sequential") {
GD01 <- t(sapply(1:length(mTreeH), function(x) gd_apply(ths, mTreeH[[x]], mTreeS[[x]], HS)))
colnames(GD01) <- LFGD01[,3]
return(GD01)
} else {
cores <- makeClusterPSOCK(workers = cl)
for(i in 1:length(mTreeH)){
GD01 <- parSapply(cores, 1, gd_apply, mTreeH[[i]], mTreeS[[i]], HS)
}
colnames(GD01) <- LFGD01[,3]
return(GD01)
}
for(i in 1:length(mTreeH)){
GD01 <- parSapply(cores, 1:length(mTreeH), gd_apply, mTreeH[[i]], mTreeS[[i]], HS)
}
for(i in 1:length(mTreeH)){
GD01 <- parSapply(cores, 1:length(mTreeH), gd_apply, mTreeH[[i]], mTreeS[[i]])
}
GD01 <- parSapply(cores, 1:length(mTreeH), function(x) gd_apply(ths, mTreeH[[x]], mTreeS[[x]], HS)))
GD01 <- parSapply(cores, 1:length(mTreeH), function(x) gd_apply(ths, mTreeH[[x]], mTreeS[[x]], HS))
GD01 <- parSapply(cores, 1:length(mTreeH), function(ths, mTreeH, mTreeS, HS) {
GD.CI <- RandomTaPas::geo_D(ths, treeH=mTreeH, treeS=mTreeS)
LFGD01.CI <- RandomTaPas::link_freq(ths, GD.CI, HS, percentile = percentile,
res.fq = res.fq, below.p = below.p)
return(LFGD01.CI[, ncol(LFGD01.CI)])
})
GD01 <- parSapply(cores, 1:length(mTreeH), function(ths, mTreeH, mTreeS, HS) {
GD.CI <- RandomTaPas::geo_D(ths, treeH=mTreeH, treeS=mTreeS)
LFGD01.CI <- RandomTaPas::link_freq(ths, GD.CI, HS, percentile = percentile,
res.fq = res.fq, below.p = below.p)
return(LFGD01.CI[, ncol(LFGD01.CI)])
}, mTreeH[[x]])
GD01 <- parSapply(cores, 1:length(mTreeH), function(ths, mTreeH, mTreeS, HS) {
GD.CI <- RandomTaPas::geo_D(ths, treeH=mTreeH, treeS=mTreeS)
LFGD01.CI <- RandomTaPas::link_freq(ths, GD.CI, HS, percentile = percentile,
res.fq = res.fq, below.p = below.p)
return(LFGD01.CI[, ncol(LFGD01.CI)])
}, mTreeH[[x]])
GD01 <- parSapply(cores, 1:length(mTreeH), function(ths, mTreeH, mTreeS, HS) {
GD.CI <- RandomTaPas::geo_D(ths, treeH=mTreeH, treeS=mTreeS)
LFGD01.CI <- RandomTaPas::link_freq(ths, GD.CI, HS, percentile = percentile,
res.fq = res.fq, below.p = below.p)
return(LFGD01.CI[, ncol(LFGD01.CI)])
}, mTreeH[[1]])
GD01 <- parSapply(cores, 1:length(mTreeH), function(ths, mTreeH, mTreeS, HS) {
GD.CI <- RandomTaPas::geo_D(ths, treeH=mTreeH, treeS=mTreeS)
LFGD01.CI <- RandomTaPas::link_freq(ths, GD.CI, HS, percentile = percentile,
res.fq = res.fq, below.p = below.p)
return(LFGD01.CI[, ncol(LFGD01.CI)])
}, mTreeH[[1]], mTreeS[[1]])
geoD <- function (ths, treeH, treeS) {
treeh <- drop.tip(treeH, setdiff(treeH$tip.label, rownames(ths)))
trees <- drop.tip(treeS, setdiff(treeS$tip.label, colnames(ths)))
ths <- ths[treeh$tip.label, trees$tip.label]
ths.lut <- which(ths[treeh$tip.label, trees$tip.label]==1, arr.ind = TRUE)
dummy.labels <- rownames(ths.lut)
trees$tip.label <- dummy.labels
combo.tree <- list(treeh, trees)
gd <- dist.multiPhylo(combo.tree)
return(gd)
}
if(strat == "sequential") {
for(i in 1:length(mTreeH)){
GD01 <- sapply(ths, geoD, treeH = mTreeH[[i]], treeS = mTreeS[[i]])
LFGD01.CI <- link_freq(ths, GD.CI, HS, percentile = percentile,
res.fq = res.fq, below.p = below.p)
return(LFGD01.CI[, ncol(LFGD01.CI)])
}
colnames(GD01) <- LFGD01[,3]
return(GD01)
} else {
cores <- makeClusterPSOCK(workers = cl)
for(i in 1:length(mTreeH)){
GD01 <- parSapply(cores, ths, geoD, treeH = mTreeH[[i]], treeS = mTreeS[[i]])
LFGD01.CI <- link_freq(ths, GD.CI, HS, percentile = percentile,
res.fq = res.fq, below.p = below.p)
return(LFGD01.CI[, ncol(LFGD01.CI)])
}
stopCluster(cores)
colnames(GD01) <- LFGD01[,3]
return(GD01)
}
geoD <- function (ths, treeH, treeS) {
treeh <- ape:.drop.tip(treeH, setdiff(treeH$tip.label, rownames(ths)))
trees <- ape::drop.tip(treeS, setdiff(treeS$tip.label, colnames(ths)))
ths <- ths[treeh$tip.label, trees$tip.label]
ths.lut <- which(ths[treeh$tip.label, trees$tip.label]==1, arr.ind = TRUE)
dummy.labels <- rownames(ths.lut)
trees$tip.label <- dummy.labels
combo.tree <- list(treeh, trees)
gd <- ape::dist.multiPhylo(combo.tree)
return(gd)
}
if(strat == "sequential") {
for(i in 1:length(mTreeH)){
GD01 <- sapply(ths, geoD, treeH = mTreeH[[i]], treeS = mTreeS[[i]])
LFGD01.CI <- link_freq(ths, GD.CI, HS, percentile = percentile,
res.fq = res.fq, below.p = below.p)
return(LFGD01.CI[, ncol(LFGD01.CI)])
}
colnames(GD01) <- LFGD01[,3]
return(GD01)
} else {
cores <- makeClusterPSOCK(workers = cl)
for(i in 1:length(mTreeH)){
GD01 <- parSapply(cores, ths, geoD, treeH = mTreeH[[i]], treeS = mTreeS[[i]])
LFGD01.CI <- link_freq(ths, GD.CI, HS, percentile = percentile,
res.fq = res.fq, below.p = below.p)
return(LFGD01.CI[, ncol(LFGD01.CI)])
}
stopCluster(cores)
colnames(GD01) <- LFGD01[,3]
return(GD01)
}
geoD <- function (ths, treeH, treeS) {
treeh <- ape::drop.tip(treeH, setdiff(treeH$tip.label, rownames(ths)))
trees <- ape::drop.tip(treeS, setdiff(treeS$tip.label, colnames(ths)))
ths <- ths[treeh$tip.label, trees$tip.label]
ths.lut <- which(ths[treeh$tip.label, trees$tip.label]==1, arr.ind = TRUE)
dummy.labels <- rownames(ths.lut)
trees$tip.label <- dummy.labels
combo.tree <- list(treeh, trees)
gd <- ape::dist.multiPhylo(combo.tree)
return(gd)
}
if(strat == "sequential") {
for(i in 1:length(mTreeH)){
GD01 <- sapply(ths, geoD, treeH = mTreeH[[i]], treeS = mTreeS[[i]])
LFGD01.CI <- link_freq(ths, GD.CI, HS, percentile = percentile,
res.fq = res.fq, below.p = below.p)
return(LFGD01.CI[, ncol(LFGD01.CI)])
}
colnames(GD01) <- LFGD01[,3]
return(GD01)
} else {
cores <- makeClusterPSOCK(workers = cl)
for(i in 1:length(mTreeH)){
GD01 <- parSapply(cores, ths, geoD, treeH = mTreeH[[i]], treeS = mTreeS[[i]])
LFGD01.CI <- link_freq(ths, GD.CI, HS, percentile = percentile,
res.fq = res.fq, below.p = below.p)
return(LFGD01.CI[, ncol(LFGD01.CI)])
}
stopCluster(cores)
colnames(GD01) <- LFGD01[,3]
return(GD01)
}
geoD <- function (ths, treeH, treeS) {
treeh <- ape::drop.tip(treeH, setdiff(treeH$tip.label, rownames(ths)))
trees <- ape::drop.tip(treeS, setdiff(treeS$tip.label, colnames(ths)))
ths <- ths[treeh$tip.label, trees$tip.label]
ths.lut <- which(ths[treeh$tip.label, trees$tip.label]==1, arr.ind = TRUE)
dummy.labels <- rownames(ths.lut)
trees$tip.label <- dummy.labels
combo.tree <- list(treeh, trees)
gd <- distory::dist.multiPhylo(combo.tree)
return(gd)
}
if(strat == "sequential") {
for(i in 1:length(mTreeH)){
GD01 <- sapply(ths, geoD, treeH = mTreeH[[i]], treeS = mTreeS[[i]])
LFGD01.CI <- link_freq(ths, GD.CI, HS, percentile = percentile,
res.fq = res.fq, below.p = below.p)
return(LFGD01.CI[, ncol(LFGD01.CI)])
}
colnames(GD01) <- LFGD01[,3]
return(GD01)
} else {
cores <- makeClusterPSOCK(workers = cl)
for(i in 1:length(mTreeH)){
GD01 <- parSapply(cores, ths, geoD, treeH = mTreeH[[i]], treeS = mTreeS[[i]])
LFGD01.CI <- link_freq(ths, GD.CI, HS, percentile = percentile,
res.fq = res.fq, below.p = below.p)
return(LFGD01.CI[, ncol(LFGD01.CI)])
}
stopCluster(cores)
colnames(GD01) <- LFGD01[,3]
return(GD01)
}
if(strat == "sequential") {
for(i in 1:length(mTreeH)){
GD01 <- sapply(ths, geoD, treeH = mTreeH[[i]], treeS = mTreeS[[i]])
LFGD01.CI <- link_freq(ths, GD01, HS, percentile = percentile,
res.fq = res.fq, below.p = below.p)
return(LFGD01.CI[, ncol(LFGD01.CI)])
}
colnames(GD01) <- LFGD01[,3]
return(GD01)
} else {
cores <- makeClusterPSOCK(workers = cl)
for(i in 1:length(mTreeH)){
GD01 <- parSapply(cores, ths, geoD, treeH = mTreeH[[i]], treeS = mTreeS[[i]])
LFGD01.CI <- link_freq(ths, GD01, HS, percentile = percentile,
res.fq = res.fq, below.p = below.p)
return(LFGD01.CI[, ncol(LFGD01.CI)])
}
stopCluster(cores)
colnames(GD01) <- LFGD01[,3]
return(GD01)
}
cores <- makeClusterPSOCK(workers = cl)
for(i in 1:length(mTreeH)){
GD01 <- parSapply(cores, ths, geoD, treeH = mTreeH[[i]], treeS = mTreeS[[i]])
LFGD01.CI <- link_freq(ths, GD01, HS, percentile = percentile,
res.fq = res.fq, below.p = below.p)
return(LFGD01.CI[, ncol(LFGD01.CI)])
}
for(i in 1:length(mTreeH)){
GD01 <- parSapply(cores, ths, geoD, treeH = mTreeH[[i]], treeS = mTreeS[[i]])
LFGD01.CI <- link_freq(ths, GD01, HS, percentile = percentile,
res.fq = res.fq, below.p = below.p)
return(LFGD01.CI[, ncol(LFGD01.CI)])
}
GD01
GD01 <- parSapply(cores, 1:length(mTreeH), geo_D, treeH = mTreeH, treeS = mTreeS)
for(i in 1:length(mTreeH)){
GD01 <- parSapply(cores, 1:length(mTreeH), geo_D, treeH = mTreeH[[i]], treeS = mTreeS[[i]])
LFGD01.CI <- link_freq(ths, GD01, HS, percentile = percentile,
res.fq = res.fq, below.p = below.p)
return(LFGD01.CI[, ncol(LFGD01.CI)])
}
GD01 <- parSapply(cores, 1:length(mTreeH), geo_D, treeH = mTreeH[[1]], treeS = mTreeS[[1]])
GD01 <- parSapply(cores, 1:length(mTreeH[[1]]), geo_D, treeH = mTreeH[[1]], treeS = mTreeS[[1]])
GD01 <- parSapply(cores, 1:length(mTreeH[[1]]), geo_D, treeH = mTreeH[[1]], treeS = mTreeS[[1]])
library(devtools)
library(roxygen2)
library(tidyverse)
devtools::load_all()
install.packages("installr")
library(installr)
updateR()
devtools::load_all()
devtools::document()
devtools::install()
devtools::load_all()
devtools::document()
devtools::install()
devtools::load_all()
devtools::document()
devtools::install()
devtools::load_all()
devtools::document()
devtools::install()
use_r("gini_plot")
library(devtools)
library(roxygen2)
library(tidyverse)
use_r("gini_plot")
boxplot(ginis, ylab="Normalized Gini coefficient", col="lightblue",
las=3)
use_r("gini_plot")
devtools::load_all()
devtools::document()
devtools::install()
use_r("one2one_f")
use_r("trimHS_maxC")
use_r("prob_statistic")
use_r("linkf_CI")
use_r("linkf_CI")
use_r("prob_statistic")
devtools::load_all()
devtools::document()
devtools::install()
devtools::load_all()
devtools::document()
devtools::install()
use_r("linkf_CI")
devtools::load_all()
devtools::document()
devtools::install()
use_r("gini_plot")
devtools::load_all()
devtools::document()
devtools::install()
devtools::load_all()
devtools::document()
devtools::install()
use_r("gini_plot")
use_r("paraF")
devtools::load_all()
devtools::document()
devtools::install()
devtools::load_all()
devtools::document()
devtools::install()
use_r("incong_tangle")
use_r("paco_ss")
library(devtools)
library(roxygen2)
library(tidyverse)
use_r("assoc_mat")
use_r("one2one_f")
use_r("trimHS_maxC")
use_r("geo_D")
use_r("paco_ss")
use_r("link_freq")
use_r("tangle_gram")
use_r("linkf_CI")
use_r("trimHS_maxI")
use_r("paraF")
use_r("incong_tangle")
use_r("prob_statistic")
use_r("trimHS_maxC")
use_r("geo_D")
use_r("geo_D")
use_r("paco_ss")
use_r("link_freq")
use_r("linkf_CI")
use_r("link_freq")
use_r("gini_plot")
devtools::load_all()
devtools::document()
devtools::install()
library(devtools)
library(roxygen2)
library(tidyverse)
devtools::load_all()
devtools::document()
devtools::install()
devtools::load_all()
devtools::document()
devtools::install()
devtools::load_all()
devtools::document()
devtools::install()
use_r("paraF")
library(devtools)
use_r("paraF")
devtools::use_r("paraF")
usethis::use_r("paraF")
devtools::load_all()
devtools::document()
devtools::install()
usethis::use_r("max_cong")
usethis::use_r("max_incong")
usethis::use_r("trimHS_maxC")
usethis::use_r("link_freq")
usethis::use_r("paco_ss")
usethis::use_r("trimHS_maxC")
usethis::use_r("tangle_gram")
devtools::load_all()
devtools::document()
usethis::use_r("prob_statistic")
usethis::use_r("gini_plot")
devtools::load_all()
devtools::load_all()
devtools::document()
devtools::load_all()
devtools::document()
devtools::load_all()
devtools::document()
usethis::use_r("max_cong")
devtools::load_all()
devtools::document()
devtools::load_all()
devtools::document()
usethis::use_r("max_cong")
devtools::load_all()
devtools::document()
devtools::load_all()
devtools::document()
usethis::use_r("max_cong")
usethis::use_r("link_freq")
devtools::load_all()
devtools::document()
usethis::use_r("max_incong")
usethis::use_r("max_incong")
devtools::load_all()
devtools::document()
use_readme_md()
library(devtools)
library(roxygen2)
library(tidyverse)
use_readme_md()
# Rtapas
use_test("assoc_mat")
test_that("multiplication works", {
expect_equal(2 * 2, 4)
})
usethis::use_testthat()
usethis::use_testthat()
use_test("assoc_mat")
use_test("trimHS_maxI")
use_test("trimHS_maxC")
use_test("one2one_f")
use_test("geo_D")
use_test("paco_ss")
use_test("paraF")
use_test("link_freq")
use_test("prob_statistic")
use_test("linkf_CI")
use_test("gini_plot")
use_test("tangle_gram")
use_test("incong_tangle")
devtools::check()
usethis::use_testthat()
use_test("assoc_mat")
use_test("trimHS_maxI")
use_test("trimHS_maxC")
use_test("one2one_f")
use_test("geo_D")
use_test("paco_ss")
use_test("paraF")
use_test("link_freq")
use_test("prob_statistic")
use_test("linkf_CI")
use_test("gini_plot")
use_test("tangle_gram")
use_test("incong_tangle")
usethis::use_mit_license("MIT")
usethis::use_mit_license("MIT")
usethis::use_r("assoc_mat")
#then insert roxygen skeleton in .R function file
usethis::use_r("one2one_f")
usethis::use_r("trimHS_maxC")
usethis::use_r("geo_D")
usethis::use_r("paco_ss")
usethis::use_r("link_freq")
usethis::use_r("tangle_gram")
usethis::use_r("linkf_CI")
usethis::use_r("trimHS_maxI")
usethis::use_r("paraF")
usethis::use_r("incong_tangle")
usethis::use_r("gini_plot")
usethis::use_r("prob_statistic")
devtools::load_all()
devtools::document()
devtools::check()
use_package("paco")
use_package("phytools")
use_package("distory")
use_package("vegan")
use_package("GiniWegNeg")
use_package("ape")
use_package("stats")
use_package("parallelly")
use_package("parallel")
use_test("geo_D")
usethis::use_r("geo_D")
devtools::load_all()
devtools::document()
devtools::install()
devtools::load_all()
devtools::document()
