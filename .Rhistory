}
GD01 <- parSapply(cores, 1:length(mTreeH), gd_apply, ths, mTreeH[[i]],
mTreeS[[i]], HS)
for (i in 1:length(mTreeH)) {
GD01 <- parSapply(cores, 1:length(mTreeH), gd_apply, ths, mTreeH[[i]],
mTreeS[[i]], HS)
}
GD01 <- parSapply(cores, 1:length(mTreeH), function(x) gd_apply(ths, mTreeH[[x]], mTreeS[[x]], HS)))
GD01 <- parSapply(cores, 1:length(mTreeH), function(x) gd_apply(ths, mTreeH[[x]], mTreeS[[x]], HS))
cores <- makeClusterPSOCK(workers = 5)
cores <- makeClusterPSOCK(workers = 5)
clusterExport(cores)
clusterExport(cores, "gd_apply")
GD01 <- parSapply(cores, 1:length(mTreeH), function(x) gd_apply(ths, mTreeH[[x]], mTreeS[[x]], HS))
library(RandomTaPas)
GD01 <- parSapply(cores, 1:length(mTreeH), function(x) gd_apply(ths, mTreeH[[x]], mTreeS[[x]], HS))
GD01 <- parallel::parSapply(cores, 1:length(mTreeH), gd_apply, ths, mTreeH[[i]], mTreeS[[i]], HS)
cores <- makeClusterPSOCK(workers = 5)
library(RandomTaPas)
cores <- makeClusterPSOCK(workers = 5)
for(i in 1:length(mTreeH)){
GD01 <- parallel::parSapply(cores, 1:length(mTreeH), gd_apply, ths, mTreeH[[i]], mTreeS[[i]], HS)
}
GD01 <- parallel::parLapply(cores, 1:length(mTreeH), gd_apply, ths, mTreeH[[i]], mTreeS[[i]], HS)
GD01 <- parallel::parSapplyLB(cores, 1:length(mTreeH), gd_apply, ths, mTreeH[[i]], mTreeS[[i]], HS)
GD01 <- parallel::parSapplyLB(cores, 1:length(mTreeH), FUN = function(ths, mTreeH, mTreeS, HS) {
GD.CI <- geo_D(ths, treeH=mTreeH, treeS=mTreeS)
LFGD01.CI <- link_freq(ths, GD.CI, HS, percentile = percentile,
res.fq = res.fq, below.p = below.p)
return(LFGD01.CI[, ncol(LFGD01.CI)])})
for(i in 1:length(mTreeH)){
GD01 <- parallel::parSapplyLB(cores, 1:length(mTreeH), FUN = function(ths, mTreeH, mTreeS, HS) {
GD.CI <- geo_D(ths, treeH=mTreeH, treeS=mTreeS)
LFGD01.CI <- link_freq(ths, GD.CI, HS, percentile = percentile,
res.fq = res.fq, below.p = below.p)
return(LFGD01.CI[, ncol(LFGD01.CI)])})
}
for(i in 1:length(mTreeH)){
GD01 <- parallel::parSapplyLB(cores, 1:length(mTreeH), FUN = function(ths, mTreeH, mTreeS, HS) {
GD.CI <- RandomTaPas::geo_D(ths, treeH=mTreeH, treeS=mTreeS)
LFGD01.CI <- RandomTaPas::link_freq(ths, GD.CI, HS, percentile = percentile,
res.fq = res.fq, below.p = below.p)
return(LFGD01.CI[, ncol(LFGD01.CI)])})
}
return(LFGD01.CI[, ncol(LFGD01.CI)])}
GD01 <- parallel::parSapplyLB(cores, 1:length(mTreeH), FUN = gd_apply, ths, mTreeH[[i]], mTreeS[[i]], HS)
for(i in 1:length(mTreeH)){
GD01 <- parallel::parSapplyLB(cores, 1:length(mTreeH), FUN = gd_apply, ths, mTreeH[[i]], mTreeS[[i]], HS)
}
GD01 <- parallel::parSapplyLB(cores, 1:length(mTreeH), FUN = gd_apply(ths, mTreeH[[i]], mTreeS[[i]], HS))
for(i in 1:length(mTreeH)){
GD01 <- parallel::parSapplyLB(cores, 1:length(mTreeH), FUN = gd_apply(ths, mTreeH[[i]], mTreeS[[i]], HS))
}
for(i in 1:length(mTreeH)){
GD01 <- parallel::parSapplyLB(cores, 1:length(mTreeH), FUN = function(ths, mTreeH, mTreeS, HS) {
GD.CI <-  RandomTaPas::geo_D(ths, treeH=mTreeH, treeS=mTreeS)
LFGD01.CI <-  RandomTaPas::link_freq(ths, GD.CI, HS, percentile = percentile,
res.fq = res.fq, below.p = below.p)
return(LFGD01.CI[, ncol(LFGD01.CI)])}, ths, mTreeH[[i]], mTreeS[[i]], HS)
}
stopCluster(cores)
cores <- makeClusterPSOCK(workers = 5)
clusterExport(cores, "gd_apply")
for(i in 1:length(mTreeH)){
GD01 <- parallel::parSapplyLB(cores, function(x) gd_apply(ths, mTreeH[[x]], mTreeS[[x]], HS))
}
for(i in 1:length(mTreeH)){
GD01 <- parallel::parSapplyLB(cores, 1:length(mTreeH), function(x) gd_apply(ths, mTreeH[[x]], mTreeS[[x]], HS))
}
return(LFGD01.CI[, ncol(LFGD01.CI)])}
gd_apply <- function(ths, mTreeH, mTreeS, HS) {
GD.CI <-  RandomTaPas::geo_D(ths, treeH=mTreeH, treeS=mTreeS)
LFGD01.CI <-  RandomTaPas::link_freq(ths, GD.CI, HS, percentile = percentile,
res.fq = res.fq, below.p = below.p)
return(LFGD01.CI[, ncol(LFGD01.CI)])}
for(i in 1:length(mTreeH)){
GD01 <- parallel::parSapplyLB(cores, 1:length(mTreeH), function(x) gd_apply(ths, mTreeH[[x]], mTreeS[[x]], HS))
}
View(gd_apply)
GD01 <- parallel::parSapply(cores, 1:5, gd_apply, ths, mTreeH = mTreeH[[x]], mTreeS = mTreeS[[x]], HS)
GD01 <- parallel::parSapply(cores, 1:5, gd_apply, ths, mTreeH = mTreeH[[i]], mTreeS = mTreeS[[i]], HS)
View(mTreeH)
mTreeH[["UNTITLED"]]
GD01 <- parallel::parSapply(cores, 1:5, gd_apply, ths = ths, mTreeH = mTreeH[[i]], mTreeS = mTreeS[[i]], HS)
GD01 <- prob_statistic(THS, HS, mTreeH[1:5], mTreeS[1:5], freqfun = "geo_D",
GDc, strat = "parallel", cl = 14)
library(RandomTaPas)
GD01 <- prob_statistic(ths = THS, HS, mTreeH[1:5], mTreeS[1:5], freqfun = "geo_D",
GDc, strat = "parallel", cl = 14)
freqfun = "geo_D"
strat = "parallel"
gd_apply <- function(ths, mTreeH, mTreeS, HS) {
GD.CI <- geo_D(ths, treeH=mTreeH, treeS=mTreeS)
LFGD01.CI <- link_freq(ths, GD.CI, HS, percentile = percentile,
res.fq = res.fq, below.p = below.p)
return(LFGD01.CI[, ncol(LFGD01.CI)])
}
if(strat == "sequential") {
GD01 <- t(sapply(1:length(mTreeH), function(x) gd_apply(ths, mTreeH[[x]], mTreeS[[x]], HS)))
colnames(GD01) <- LFGD01[,3]
return(GD01)
} else {
cores <- makeClusterPSOCK(workers = cl)
GD01 <- t(parSapply(cores, 1:length(mTreeH), function(x) gd_apply(ths, treeH=mTreeH[[x]], treeS=mTreeS[[x]], HS)))
colnames(GD01) <- LFGD01[,3]
return(GD01)
}
cl=5
if(strat == "sequential") {
GD01 <- t(sapply(1:length(mTreeH), function(x) gd_apply(ths, mTreeH[[x]], mTreeS[[x]], HS)))
colnames(GD01) <- LFGD01[,3]
return(GD01)
} else {
cores <- makeClusterPSOCK(workers = cl)
GD01 <- t(parSapply(cores, 1:length(mTreeH), function(x) gd_apply(ths, treeH=mTreeH[[x]], treeS=mTreeS[[x]], HS)))
colnames(GD01) <- LFGD01[,3]
return(GD01)
}
gd_apply <- function(ths, mTreeH, mTreeS, HS) {
GD.CI <- RandomTaPas::geo_D(ths, treeH=mTreeH, treeS=mTreeS)
LFGD01.CI <- RandomTaPas::link_freq(ths, GD.CI, HS, percentile = percentile,
res.fq = res.fq, below.p = below.p)
return(LFGD01.CI[, ncol(LFGD01.CI)])
}
if(strat == "sequential") {
GD01 <- t(sapply(1:length(mTreeH), function(x) gd_apply(ths, mTreeH[[x]], mTreeS[[x]], HS)))
colnames(GD01) <- LFGD01[,3]
return(GD01)
} else {
cores <- makeClusterPSOCK(workers = cl)
clusterExport(cl=cores, c("gd_apply"))
GD01 <- t(parSapply(cores, 1:length(mTreeH), function(x) gd_apply(ths, treeH=mTreeH[[x]], treeS=mTreeS[[x]], HS)))
colnames(GD01) <- LFGD01[,3]
return(GD01)
}
GD01 <- t(parSapply(cores, 1:length(mTreeH), function(x) gd_apply(ths = THS, mTreeH[[x]], mTreeS[[x]], HS)))
if(strat == "sequential") {
GD01 <- t(sapply(1:length(mTreeH), function(x) gd_apply(ths, mTreeH[[x]], mTreeS[[x]], HS)))
colnames(GD01) <- LFGD01[,3]
return(GD01)
} else {
cores <- makeClusterPSOCK(workers = cl)
clusterExport(cl=cores, c("gd_apply"))
GD01 <- t(parSapply(cores, 1:length(mTreeH), function(x) gd_apply(ths = THS, mTreeH[[x]], mTreeS[[x]], HS)))
colnames(GD01) <- LFGD01[,3]
return(GD01)
}
cores <- makeClusterPSOCK(workers = cl)
GD01 <- parSapply(cores, 1:length(mTreeH), gd_apply, mTreeH[[x]], mTreeS[[x]], HS)
if(strat == "sequential") {
GD01 <- t(sapply(1:length(mTreeH), function(x) gd_apply(ths, mTreeH[[x]], mTreeS[[x]], HS)))
colnames(GD01) <- LFGD01[,3]
return(GD01)
} else {
cores <- makeClusterPSOCK(workers = cl)
for(i in 1:length(mTreeH)){
GD01 <- parSapply(cores, 1:length(mTreeH), gd_apply, mTreeH[[x]], mTreeS[[x]], HS)
}
colnames(GD01) <- LFGD01[,3]
return(GD01)
}
GD01 <- parSapply(cores, 1:length(mTreeH), gd_apply, mTreeH[[i]], mTreeS[[i]], HS)
if(strat == "sequential") {
GD01 <- t(sapply(1:length(mTreeH), function(x) gd_apply(ths, mTreeH[[x]], mTreeS[[x]], HS)))
colnames(GD01) <- LFGD01[,3]
return(GD01)
} else {
cores <- makeClusterPSOCK(workers = cl)
for(i in 1:length(mTreeH)){
GD01 <- parSapply(cores, 1:length(mTreeH), gd_apply, mTreeH[[i]], mTreeS[[i]], HS)
}
colnames(GD01) <- LFGD01[,3]
return(GD01)
}
if(strat == "sequential") {
GD01 <- t(sapply(1:length(mTreeH), function(x) gd_apply(ths, mTreeH[[x]], mTreeS[[x]], HS)))
colnames(GD01) <- LFGD01[,3]
return(GD01)
} else {
cores <- makeClusterPSOCK(workers = cl)
for(i in 1:length(mTreeH)){
GD01 <- parSapply(cores, 1, gd_apply, mTreeH[[i]], mTreeS[[i]], HS)
}
colnames(GD01) <- LFGD01[,3]
return(GD01)
}
for(i in 1:length(mTreeH)){
GD01 <- parSapply(cores, 1:length(mTreeH), gd_apply, mTreeH[[i]], mTreeS[[i]], HS)
}
for(i in 1:length(mTreeH)){
GD01 <- parSapply(cores, 1:length(mTreeH), gd_apply, mTreeH[[i]], mTreeS[[i]])
}
GD01 <- parSapply(cores, 1:length(mTreeH), function(x) gd_apply(ths, mTreeH[[x]], mTreeS[[x]], HS)))
GD01 <- parSapply(cores, 1:length(mTreeH), function(x) gd_apply(ths, mTreeH[[x]], mTreeS[[x]], HS))
GD01 <- parSapply(cores, 1:length(mTreeH), function(ths, mTreeH, mTreeS, HS) {
GD.CI <- RandomTaPas::geo_D(ths, treeH=mTreeH, treeS=mTreeS)
LFGD01.CI <- RandomTaPas::link_freq(ths, GD.CI, HS, percentile = percentile,
res.fq = res.fq, below.p = below.p)
return(LFGD01.CI[, ncol(LFGD01.CI)])
})
GD01 <- parSapply(cores, 1:length(mTreeH), function(ths, mTreeH, mTreeS, HS) {
GD.CI <- RandomTaPas::geo_D(ths, treeH=mTreeH, treeS=mTreeS)
LFGD01.CI <- RandomTaPas::link_freq(ths, GD.CI, HS, percentile = percentile,
res.fq = res.fq, below.p = below.p)
return(LFGD01.CI[, ncol(LFGD01.CI)])
}, mTreeH[[x]])
GD01 <- parSapply(cores, 1:length(mTreeH), function(ths, mTreeH, mTreeS, HS) {
GD.CI <- RandomTaPas::geo_D(ths, treeH=mTreeH, treeS=mTreeS)
LFGD01.CI <- RandomTaPas::link_freq(ths, GD.CI, HS, percentile = percentile,
res.fq = res.fq, below.p = below.p)
return(LFGD01.CI[, ncol(LFGD01.CI)])
}, mTreeH[[x]])
GD01 <- parSapply(cores, 1:length(mTreeH), function(ths, mTreeH, mTreeS, HS) {
GD.CI <- RandomTaPas::geo_D(ths, treeH=mTreeH, treeS=mTreeS)
LFGD01.CI <- RandomTaPas::link_freq(ths, GD.CI, HS, percentile = percentile,
res.fq = res.fq, below.p = below.p)
return(LFGD01.CI[, ncol(LFGD01.CI)])
}, mTreeH[[1]])
GD01 <- parSapply(cores, 1:length(mTreeH), function(ths, mTreeH, mTreeS, HS) {
GD.CI <- RandomTaPas::geo_D(ths, treeH=mTreeH, treeS=mTreeS)
LFGD01.CI <- RandomTaPas::link_freq(ths, GD.CI, HS, percentile = percentile,
res.fq = res.fq, below.p = below.p)
return(LFGD01.CI[, ncol(LFGD01.CI)])
}, mTreeH[[1]], mTreeS[[1]])
geoD <- function (ths, treeH, treeS) {
treeh <- drop.tip(treeH, setdiff(treeH$tip.label, rownames(ths)))
trees <- drop.tip(treeS, setdiff(treeS$tip.label, colnames(ths)))
ths <- ths[treeh$tip.label, trees$tip.label]
ths.lut <- which(ths[treeh$tip.label, trees$tip.label]==1, arr.ind = TRUE)
dummy.labels <- rownames(ths.lut)
trees$tip.label <- dummy.labels
combo.tree <- list(treeh, trees)
gd <- dist.multiPhylo(combo.tree)
return(gd)
}
if(strat == "sequential") {
for(i in 1:length(mTreeH)){
GD01 <- sapply(ths, geoD, treeH = mTreeH[[i]], treeS = mTreeS[[i]])
LFGD01.CI <- link_freq(ths, GD.CI, HS, percentile = percentile,
res.fq = res.fq, below.p = below.p)
return(LFGD01.CI[, ncol(LFGD01.CI)])
}
colnames(GD01) <- LFGD01[,3]
return(GD01)
} else {
cores <- makeClusterPSOCK(workers = cl)
for(i in 1:length(mTreeH)){
GD01 <- parSapply(cores, ths, geoD, treeH = mTreeH[[i]], treeS = mTreeS[[i]])
LFGD01.CI <- link_freq(ths, GD.CI, HS, percentile = percentile,
res.fq = res.fq, below.p = below.p)
return(LFGD01.CI[, ncol(LFGD01.CI)])
}
stopCluster(cores)
colnames(GD01) <- LFGD01[,3]
return(GD01)
}
geoD <- function (ths, treeH, treeS) {
treeh <- ape:.drop.tip(treeH, setdiff(treeH$tip.label, rownames(ths)))
trees <- ape::drop.tip(treeS, setdiff(treeS$tip.label, colnames(ths)))
ths <- ths[treeh$tip.label, trees$tip.label]
ths.lut <- which(ths[treeh$tip.label, trees$tip.label]==1, arr.ind = TRUE)
dummy.labels <- rownames(ths.lut)
trees$tip.label <- dummy.labels
combo.tree <- list(treeh, trees)
gd <- ape::dist.multiPhylo(combo.tree)
return(gd)
}
if(strat == "sequential") {
for(i in 1:length(mTreeH)){
GD01 <- sapply(ths, geoD, treeH = mTreeH[[i]], treeS = mTreeS[[i]])
LFGD01.CI <- link_freq(ths, GD.CI, HS, percentile = percentile,
res.fq = res.fq, below.p = below.p)
return(LFGD01.CI[, ncol(LFGD01.CI)])
}
colnames(GD01) <- LFGD01[,3]
return(GD01)
} else {
cores <- makeClusterPSOCK(workers = cl)
for(i in 1:length(mTreeH)){
GD01 <- parSapply(cores, ths, geoD, treeH = mTreeH[[i]], treeS = mTreeS[[i]])
LFGD01.CI <- link_freq(ths, GD.CI, HS, percentile = percentile,
res.fq = res.fq, below.p = below.p)
return(LFGD01.CI[, ncol(LFGD01.CI)])
}
stopCluster(cores)
colnames(GD01) <- LFGD01[,3]
return(GD01)
}
geoD <- function (ths, treeH, treeS) {
treeh <- ape::drop.tip(treeH, setdiff(treeH$tip.label, rownames(ths)))
trees <- ape::drop.tip(treeS, setdiff(treeS$tip.label, colnames(ths)))
ths <- ths[treeh$tip.label, trees$tip.label]
ths.lut <- which(ths[treeh$tip.label, trees$tip.label]==1, arr.ind = TRUE)
dummy.labels <- rownames(ths.lut)
trees$tip.label <- dummy.labels
combo.tree <- list(treeh, trees)
gd <- ape::dist.multiPhylo(combo.tree)
return(gd)
}
if(strat == "sequential") {
for(i in 1:length(mTreeH)){
GD01 <- sapply(ths, geoD, treeH = mTreeH[[i]], treeS = mTreeS[[i]])
LFGD01.CI <- link_freq(ths, GD.CI, HS, percentile = percentile,
res.fq = res.fq, below.p = below.p)
return(LFGD01.CI[, ncol(LFGD01.CI)])
}
colnames(GD01) <- LFGD01[,3]
return(GD01)
} else {
cores <- makeClusterPSOCK(workers = cl)
for(i in 1:length(mTreeH)){
GD01 <- parSapply(cores, ths, geoD, treeH = mTreeH[[i]], treeS = mTreeS[[i]])
LFGD01.CI <- link_freq(ths, GD.CI, HS, percentile = percentile,
res.fq = res.fq, below.p = below.p)
return(LFGD01.CI[, ncol(LFGD01.CI)])
}
stopCluster(cores)
colnames(GD01) <- LFGD01[,3]
return(GD01)
}
geoD <- function (ths, treeH, treeS) {
treeh <- ape::drop.tip(treeH, setdiff(treeH$tip.label, rownames(ths)))
trees <- ape::drop.tip(treeS, setdiff(treeS$tip.label, colnames(ths)))
ths <- ths[treeh$tip.label, trees$tip.label]
ths.lut <- which(ths[treeh$tip.label, trees$tip.label]==1, arr.ind = TRUE)
dummy.labels <- rownames(ths.lut)
trees$tip.label <- dummy.labels
combo.tree <- list(treeh, trees)
gd <- distory::dist.multiPhylo(combo.tree)
return(gd)
}
if(strat == "sequential") {
for(i in 1:length(mTreeH)){
GD01 <- sapply(ths, geoD, treeH = mTreeH[[i]], treeS = mTreeS[[i]])
LFGD01.CI <- link_freq(ths, GD.CI, HS, percentile = percentile,
res.fq = res.fq, below.p = below.p)
return(LFGD01.CI[, ncol(LFGD01.CI)])
}
colnames(GD01) <- LFGD01[,3]
return(GD01)
} else {
cores <- makeClusterPSOCK(workers = cl)
for(i in 1:length(mTreeH)){
GD01 <- parSapply(cores, ths, geoD, treeH = mTreeH[[i]], treeS = mTreeS[[i]])
LFGD01.CI <- link_freq(ths, GD.CI, HS, percentile = percentile,
res.fq = res.fq, below.p = below.p)
return(LFGD01.CI[, ncol(LFGD01.CI)])
}
stopCluster(cores)
colnames(GD01) <- LFGD01[,3]
return(GD01)
}
if(strat == "sequential") {
for(i in 1:length(mTreeH)){
GD01 <- sapply(ths, geoD, treeH = mTreeH[[i]], treeS = mTreeS[[i]])
LFGD01.CI <- link_freq(ths, GD01, HS, percentile = percentile,
res.fq = res.fq, below.p = below.p)
return(LFGD01.CI[, ncol(LFGD01.CI)])
}
colnames(GD01) <- LFGD01[,3]
return(GD01)
} else {
cores <- makeClusterPSOCK(workers = cl)
for(i in 1:length(mTreeH)){
GD01 <- parSapply(cores, ths, geoD, treeH = mTreeH[[i]], treeS = mTreeS[[i]])
LFGD01.CI <- link_freq(ths, GD01, HS, percentile = percentile,
res.fq = res.fq, below.p = below.p)
return(LFGD01.CI[, ncol(LFGD01.CI)])
}
stopCluster(cores)
colnames(GD01) <- LFGD01[,3]
return(GD01)
}
cores <- makeClusterPSOCK(workers = cl)
for(i in 1:length(mTreeH)){
GD01 <- parSapply(cores, ths, geoD, treeH = mTreeH[[i]], treeS = mTreeS[[i]])
LFGD01.CI <- link_freq(ths, GD01, HS, percentile = percentile,
res.fq = res.fq, below.p = below.p)
return(LFGD01.CI[, ncol(LFGD01.CI)])
}
for(i in 1:length(mTreeH)){
GD01 <- parSapply(cores, ths, geoD, treeH = mTreeH[[i]], treeS = mTreeS[[i]])
LFGD01.CI <- link_freq(ths, GD01, HS, percentile = percentile,
res.fq = res.fq, below.p = below.p)
return(LFGD01.CI[, ncol(LFGD01.CI)])
}
GD01
GD01 <- parSapply(cores, 1:length(mTreeH), geo_D, treeH = mTreeH, treeS = mTreeS)
for(i in 1:length(mTreeH)){
GD01 <- parSapply(cores, 1:length(mTreeH), geo_D, treeH = mTreeH[[i]], treeS = mTreeS[[i]])
LFGD01.CI <- link_freq(ths, GD01, HS, percentile = percentile,
res.fq = res.fq, below.p = below.p)
return(LFGD01.CI[, ncol(LFGD01.CI)])
}
GD01 <- parSapply(cores, 1:length(mTreeH), geo_D, treeH = mTreeH[[1]], treeS = mTreeS[[1]])
GD01 <- parSapply(cores, 1:length(mTreeH[[1]]), geo_D, treeH = mTreeH[[1]], treeS = mTreeS[[1]])
GD01 <- parSapply(cores, 1:length(mTreeH[[1]]), geo_D, treeH = mTreeH[[1]], treeS = mTreeS[[1]])
library(devtools)
library(roxygen2)
library(tidyverse)
devtools::load_all()
install.packages("installr")
library(installr)
updateR()
devtools::load_all()
devtools::document()
devtools::install()
devtools::load_all()
devtools::document()
devtools::install()
devtools::load_all()
devtools::document()
devtools::install()
devtools::load_all()
devtools::document()
devtools::install()
use_r("gini_plot")
library(devtools)
library(roxygen2)
library(tidyverse)
use_r("gini_plot")
boxplot(ginis, ylab="Normalized Gini coefficient", col="lightblue",
las=3)
use_r("gini_plot")
devtools::load_all()
devtools::document()
devtools::install()
use_r("one2one_f")
use_r("trimHS_maxC")
use_r("prob_statistic")
use_r("linkf_CI")
use_r("linkf_CI")
use_r("prob_statistic")
devtools::load_all()
devtools::document()
devtools::install()
devtools::load_all()
devtools::document()
devtools::install()
use_r("linkf_CI")
devtools::load_all()
devtools::document()
devtools::install()
use_r("gini_plot")
devtools::load_all()
devtools::document()
devtools::install()
devtools::load_all()
devtools::document()
devtools::install()
use_r("gini_plot")
use_r("paraF")
devtools::load_all()
devtools::document()
devtools::install()
devtools::load_all()
devtools::document()
devtools::install()
use_r("incong_tangle")
use_r("paco_ss")
library(devtools)
library(roxygen2)
library(tidyverse)
use_r("assoc_mat")
use_r("one2one_f")
use_r("trimHS_maxC")
use_r("geo_D")
use_r("paco_ss")
use_r("link_freq")
use_r("tangle_gram")
use_r("linkf_CI")
use_r("trimHS_maxI")
use_r("paraF")
use_r("incong_tangle")
use_r("prob_statistic")
use_r("trimHS_maxC")
use_r("geo_D")
use_r("geo_D")
use_r("paco_ss")
use_r("link_freq")
use_r("linkf_CI")
use_r("link_freq")
use_r("gini_plot")
devtools::load_all()
devtools::document()
devtools::install()
library(devtools)
library(roxygen2)
library(tidyverse)
devtools::load_all()
devtools::document()
devtools::install()
devtools::load_all()
devtools::document()
devtools::install()
devtools::load_all()
devtools::document()
devtools::install()
use_r("paraF")
library(devtools)
use_r("paraF")
devtools::use_r("paraF")
usethis::use_r("paraF")
devtools::load_all()
devtools::document()
devtools::install()
library(devtools)
library(roxygen2)
library(tidyverse)
devtools::load_all()
devtools::document()
devtools::install()
