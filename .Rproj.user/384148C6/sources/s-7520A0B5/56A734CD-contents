#' Procrustes Approach to Cophylogeny (PACo) of the host and symbiont
#' configurations
#'
#' For any trimmed matrix produced with \code{\link[=trimHS_maxC]{trimHS_maxC()}},
#' it prunes the host (H) & symbiont (S) phylogenies to conform with the trimmed
#' matrix and runs Procrustes Approach to Cophylogeny (PACo) to produce the
#' squared sum of residuals of the Procrustes superimposition of the host and
#' symbiont configurations in Euclidean space.
#'
#'
#' @param hs Trimmed matrix.
#'
#' @param treeH Host phylogeny. An object of class \code{"phylo"}.
#'
#' @param treeS Symbiont phylogeny. An object of class \code{"phylo"}.
#'
#' @param symmetric Specifies the type of Procrustes superimposition. Default
#'        is \code{FALSE}, indicates that the superposition is applied
#'        asymmetrically (S depends on H). If \code{TRUE}, PACo is applied
#'        symmetrically (dependency between S and H is reciprocal).
#'
#' @param proc.warns Switches on/off trivial warnings returned when treeH and
#'        treeS differ in size (number of tips). Default is \code{FALSE}.
#'
#' @param ei.correct Specifies how to correct potential negative eigenvalues
#'        from the conversion of phylogenetic distances into Principal
#'        Coordinates: \code{"none"} (the default) indicates that no correction
#'        is required, particularly if H and S are ultrametric; \code{"sqrt.D"}
#'        takes the element-wise square-root of the phylogenetic distances;
#'        \code{"lingoes"} and \code{"cailliez"} apply the classical Lingoes and
#'        Cailliez corrections, respectively.
#'
#' @param session Strategy you want to work with. Default is \code{"sequential"},
#'        resolves \R expressions sequentially in the current \R
#'        process. If \code{"multisession"} and \code{"multicore"} (not
#'        supported on Windows) resolves \R expressions in parallel in separate
#'        \R sessions running in the background.
#'
#' @param cl Number of cluster the user wants to use. Check how many CPUs/cores
#'        your computer has with \code{\link[future:availableCores]{future::availableCores()}}.
#'        Note that \code{cl <= \link[=availableCores]{availableCores()}}.
#'        Default is \code{cl = 1} for \code{"sequential"} strategy.
#'
#' @return A sum of squared residuals.
#'
#' @examples
#' #paco_ss(hs, treeH, treeS)
#'
#' @import paco
#' @importFrom vegan procrustes
#'
#' @export
paco_ss <- function (hs, treeH, treeS, symmetric = FALSE,
                     proc.warns = FALSE, ei.correct = "none",
                     session = "sequential", cl = 1) {

  pacoss <- function (hs, treeH, treeS, ...) {
  eigen.choice <- c("none", "lingoes", "cailliez", "sqrt.D")
  if (ei.correct %in% eigen.choice == FALSE)
    stop(writeLines("Invalid eigenvalue correction parameter.\r
               Correct choices are 'none', 'lingoes', 'cailliez' or 'sqrt.D'"))
  treeh <- ape::drop.tip(treeH, setdiff(treeH$tip.label, rownames(hs)))
  trees <- ape::drop.tip(treeS, setdiff(treeS$tip.label, colnames(hs)))
  # Reorder hs as per tree labels:
  hs <- hs[treeh$tip.label, trees$tip.label]
  DH <- stats::cophenetic(treeh)
  DP <- stats::cophenetic(trees)
  if (ei.correct == "sqrt.D"){DH <- sqrt(DH); DP <- sqrt(DP); ei.correct ="none"}
  D <- paco::prepare_paco_data(DH, DP, hs)
  D <- paco::add_pcoord(D, correction = ei.correct)
  if (proc.warns == FALSE) D <- vegan::procrustes(D$H_PCo, D$P_PCo,
                                                  symmetric = symmetric) else
                                                    D <- suppressWarnings(vegan::procrustes(D$H_PCo, D$P_PCo,
                                                                                            symmetric = symmetric))
  return(D$ss)
  }

  session.choice <- c("sequential", "multisession", "multicore")
  if (session %in% session.choice == FALSE)
    stop(writeLines("Invalid session parameter"))

  if (session == "sequential") {
    plan(sequential)
    paco_f <- future_sapply(hs, pacoss, treeH, treeS, symmetric = FALSE,
                            proc.warns = FALSE, ei.correct = "none")
    return(paco_f)
  } else {
    plan(session, workers = cl)
    paco_f <- future_sapply(hs, pacoss, treeH, treeS, symmetric = FALSE,
                            proc.warns = FALSE, ei.correct = "none")
    plan(sequential)
    return(paco_f)
  }
}

