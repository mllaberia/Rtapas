#' Confidence intervals for the frequency of host-symbiont association
#'
#' @param ths List of trimmed matrices produced by \code{\link[=trimHS_maxC]{trimHS_maxC()}}.
#'
#' @param HS Host-Symbiont association matrix.
#'
#' @param mTreeH Number X of posterior-probabilistic trees of host.
#'
#' @param mTreeS Number X of posterior-probabilistic trees of symbiont.
#'
#' @param freqfun Options are \code{"geo_D"} or \code{"paco_ss"},
#'        depending on which confidence intervals you want to compute
#'        (apply to the result of \code{\link[=paco_ss]{paco_ss()}}
#'        or \code{\link[=geo_D]{geo_D()}}).
#'
#' @param geoD Vector of statistics produced with \code{\link[=geo_D]{geo_D()}}.
#'
#' @param paco Vector of statistics produced with \code{\link[=paco_ss]{paco_ss()}}.
#'
#' @param strat Strategy you want to work with. Default is \code{"sequential"},
#'        resolves \R expressions sequentially in the current \R
#'        process. If \code{"parallel"} resolves \R expressions in parallel in
#'        separate \R sessions running in the background.
#'
#' @param cl Number of cluster the user wants to use. Check how many CPUs/cores
#'        your computer has with \code{\link[parallelly:availableCores]{parallelly::availableCores()}}.
#'        Default is \code{cl = 1} for \code{"sequential"} strategy.
#'
#' @param percentile Percentile to evaluate. Default is \code{0.01}. The percentile
#'        applied can be specified with \code{percentile.res.fq}, determines whether
#'        to apply a correction to the estimated frequencies by setting a null
#'        model in wich the occurrence of each host-symbiont association is
#'        evenly distributed along the whole frequency distribution.
#'
#' @param res.fq Determines whether a correction to avoid one-to-one associations
#'        being overrepresented in the percentile evaluated. If \code{TRUE} (default)
#'        a residual frequency value (observed - expected frequency) is computed
#'        for each host-symbiont association.
#'
#' @param below.p Determines whether frequencies are to be computed below or
#'        above the percentile set. Default is \code{TRUE}.
#'
#' @param symmetric Specifies the type of Procrustes superimposition. Default
#'        is \code{FALSE}, indicates that the superposition is applied
#'        asymmetrically (S depends on H). If \code{TRUE}, PACo is applied
#'        symmetrically (dependency between S and H is reciprocal).
#'
#' @param ei.correct Specifies how to correct potential negative eigenvalues
#'        from the conversion of phylogenetic distances into Principal
#'        Coordinates: \code{"none"} (the default) indicates that no correction
#'        is required, particularly if H and S are ultrametric; \code{"sqrt.D"}
#'        takes the element-wise square-root of the phylogenetic distances;
#'        \code{"lingoes"} and \code{"cailliez"} apply the classical Lingoes and
#'        Cailliez corrections, respectively.
#'
#' @param barplot Default is \code{"TRUE"}, plots the distribution and confidence
#'        intervals of the frequencies.
#'
#' @param c.level ha
#'
#' @param col.bar ha
#'
#' @param col.ci ha
#'
#' @param ... Any graphical option admissible in \code{\link[=barplot]{barplot()}}
#'
#' @return A dataframe with
#'
#' @importFrom graphics arrows axis
#'
#' @export
#'
#' @examples
#' # ficus_aganoidae
#'
#'
linkf_CI <- function (ths, HS, mTreeH, mTreeS, freqfun = "geo_D", geoD, paco,
                      percentile = 0.01, res.fq = TRUE, below.p = TRUE, symmetric=FALSE, ei.correct="none",
                      strat = "sequential", cl = 1, barplot = TRUE, c.level = 95, col.bar = "lightblue", col.ci = "darkblue", ...) {

  freqfun.choice <- c("geo_D", "paco_ss")
  if(freqfun %in% freqfun.choice == FALSE)
  stop(writeLines("Invalid freqfun parameter.\r Correct choices are 'geo_D' or 'paco_ss'"))

  if(freqfun == "geo_D") {
    LFGD01 <- link_freq(ths, geoD, HS, percentile = percentile,
                        res.fq = res.fq, below.p = below.p)

    gd_apply <- function(ths, th, ts, HS) {
      GD.CI <- geo_D(ths, treeH=th, treeS=ts, strat = strat , cl = cl)
      LFGD01.CI <- link_freq(ths, GD.CI, HS, percentile = percentile,
                             res.fq = res.fq, below.p = below.p)
      return(LFGD01.CI[, ncol(LFGD01.CI)])
    }
    GD01 <- t(sapply(1:length(mTreeH), function(x) gd_apply(ths, mTreeH[[x]], mTreeS[[x]], HS)))

    colnames(GD01) <- LFGD01[,3]
    a <- 1-(c.level/100)
    GD.LO <- apply(GD01, 2, quantile, a / 2)
    GD.HI <- apply(GD01, 2, quantile, 1 - (a / 2))
    GD.AV <- apply(GD01, 2, mean)

    df <- data.frame(LFGD01[,1], LFGD01[,2], LFGD01[,ncol(LFGD01)], GD.LO, GD.HI, GD.AV)
    colnames(df) <- c("GDwFq", "GD.LO", "GD.HI", "GD.AV")

    if(barplot == TRUE) {
      link.fq <- barplot(GD.AV, xaxt = 'n',
                        horiz=FALSE, cex.names = 0.6, las=2, cex.axis=0.8,
                        ylab="Observed - Expected frequency",
                        ylim=c(min(GD.LO), max(GD.HI)), col = col.bar, ...)
      suppressWarnings(arrows(link.fq, GD.HI, link.fq, GD.LO, length= 0,
                              angle=90, code=3, col = col.ci))
      axis(side=1, at=link.fq[1:length(GD.AV)], labels=LFGD01$HS, las=2,
           tick = FALSE, line= 0.1, cex.axis=0.5)

      return(df)
    } else {return(df)}
  }

  if(freqfun == "paco_ss") {
    LFPACO01 <- link_freq (ths, paco, HS, percentile = percentile,
                           res.fq = res.fq, below.p = below.p)

    paco_apply <- function(ths, th, ts, HS) {
      PA.CI <- paco_ss(ths, treeH=th, treeS=ts,
                       symmetric = symmetric, ei.correct = ei.correct,
                       strat = strat , cl = cl)
      LFPA01.CI <- link_freq(ths, PA.CI, HS, percentile = percentile,
                             res.fq = res.fq, below.p = below.p)
      return(LFPA01.CI[, ncol(LFPA01.CI)])
    }

    PACO01 <- t(sapply(1:length(mTreeH), function(x) paco_apply(ths, mTreeH[[x]], mTreeS[[x]], HS)))

    colnames(PACO01) <- LFPACO01[,3]
    a <- 1-(c.level/100)
    PACO.LO <- apply(PACO01, 2, quantile, a / 2)
    PACO.HI <- apply(PACO01, 2, quantile, 1 - (a / 2))
    PACO.AV <- apply(PACO01, 2, mean)

    df <- data.frame(LFPACO01[,1], LFPACO01[,2], LFPACO01[, ncol(LFPACO01)], PACO.LO, PACO.HI, PACO.AV)
    colnames(df) <- c("PACOwFq", "PACO.LO", "PACO.HI", "PACO.AV")

    if(barplot == TRUE) {
      link.fq <- barplot(PACO.AV, xaxt = 'n',
                         horiz=FALSE, cex.names = 0.6, las=2, cex.axis=0.8,
                         ylab="Observed - Expected frequency",
                         ylim=c(min(PACO.LO), max(PACO.HI)), col = col.bar, ...)
      suppressWarnings(arrows(link.fq, PACO.HI, link.fq, PACO.LO, length= 0,
                              angle=90, code=3, col = col.ci))
      axis(side=1, at=link.fq[1:length(PACO.AV)], labels=LFPACO01$HS, las=2,
           tick = FALSE, line= 0.1, cex.axis=0.5)

      return(df)
    } else {return(df)}
  }
}
